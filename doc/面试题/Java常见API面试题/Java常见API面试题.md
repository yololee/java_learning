# Java常见API面试题

### 自动装箱与拆箱

**装箱**：将基本类型用它们对应的引用类型包装起来；原理：Integer.valueOf() 方法

**拆箱**：将包装类型转换为基本数据类型；原理：Integer.intValue() 方法

Java 为每个原始类型提供了包装类型：

原始类型: boolean，char，byte，short，int，long，float，double

包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

### 包装类型的常量池技术了解么？

Java 基本类型的包装类的大部分都实现了常量池技术。

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

### Integer a= 127 与 Integer b = 127相等吗

如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false

```java
    Integer a1 = 128;
    Integer b1 = 128;
    System.out.println(a1 == b1); // false

    Integer a2 = 127;
    Integer b2 = 127;
    System.out.println(a2 == b2); // true
```

### String的创建机理是什么？什么是字符串常量池？

- 创建机理：由于String在Java世界中使用过于频繁，为了提高内存的使用率，避免开辟多块空间存储相同的字符串，引入了字符串常量池（字符串常量池位于堆内存中）
- 运行机制：在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用

### String 是最基本的数据类型吗

不是。Java 中的基本数据类型只有 8 个，除了基本类型，剩下的都是引用类型基本数据

类型中用来描述文本数据的是 char，但是它只能表示单个字符，如果要描述一段文本，就需要使用 char 类型数组，但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，使用更加简便

### String s = new String(“abc”);创建了几个字符串对象

当JVM遇到上述代码时，会先检索常量池中是否存在“abc”，如果不存在“abc”这个字符串，则会先在常量池中创建这个字符串。然后再执行new操作，在堆内存中创建一个String对象，对象的引用赋值给s。此过程创建了2个对象。

当然，如果检索常量池时发现已经存在了对应的字符串，那么只会在堆内创建一个新的String对象，此过程只创建了1个对象。

### String为什么是不可变的吗？是否可以继承 String 类

final修饰的String类，代表了String类的不可被继承，final修饰的char[]代表了被存储的数据不可更改被创建，是无法修改的，即便你在后面拼接一些其他字符，也会把新生成的字符串存到另外一个地址但是，虽然final代表了不可变，但仅仅是引用地址不可变，并不代表了数组本身不会变。

### 在使用 HashMap 的时候，用 String 做 key 有什么好处？

因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。

### String str="i"与 String str=new String(“i”)一样吗？

不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。

### String 类的常用方法都有那些？

```java
indexOf()：返回指定字符的索引。
charAt()：返回指定索引处的字符。
replace()：字符串替换。
trim()：去除字符串两端空白。
split()：分割字符串，返回一个分割后的字符串数组。
getBytes()：返回字符串的 byte 类型数组。
length()：返回字符串长度。
toLowerCase()：将字符串转成小写字母。
toUpperCase()：将字符串转成大写字符。
substring()：截取字符串。
equals()：字符串比较。
```

### String和StringBuffer、StringBuilder的区别是什么？

- 可变性：

  String类中使用字符数组保存字符串，`private　final　char　value[]`，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，`char[] value`，这两种对象都是可变的。

- 线程安全性：

  String中的对象是不可变的，也就可以理解为常量，线程安全。

  StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的

  StringBuilder并没有对方法进行加同步锁，所以是非线程安全的

- 性能：

  每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象

  StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

  `StringBuilder > StringBuffer > String`

> 总结：
>
> 1、在字符串内容不经常发生变化的业务场景，优先使用String类，例如常量声明、少量的字符串拼接操作等。
>
> 2、在单线程环境下，频繁地进行字符串的操作，建议使用StringBuilder，例如SQL语句拼装、JSON封装等
>
> 3、在多线程环境下，频繁地进行字符串的操作，建议使用StringBuffer，例如XML解析、HTTP参数解析与封装

### 字符型常量和字符串常量的区别?

**形式** : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符

**含义** : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)

**占内存大小** ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (**注意： `char` 在 Java 中占两个字节**

### java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；

> InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
>
> OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

### BIO,NIO,AIO 有什么区别?

- **同步：** 同步就是发起一个请求，被调用者未处理完请求之前，调用不返回。
- **异步：** 异步就是发起一个请求，立刻得到被调用者的响应表示已接收到请求，但是被调用者并没有返回请求处理结果，此时我们可以处理其他的请求，被调用者通过事件和回调等机制来通知调用者其返回结果。
- **阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当返回结果才能继续。
- **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

> 同步和异步的区别在于调用者需不需要等待被调用者的处理结果。
>
> 阻塞和非阻塞的区别在于调用者的线程需不需要挂起。

- BIO（jdk1.4之前）：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它基于流模型实现，一个连接一个线程，客户端有连接请求时，服务器端就需要启动一个线程进行处理，线程开销大。伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。它的特点是模式简单使用方便，但并发处理能力低，容易成为应用性能的瓶颈。BIO是面向流的，BIO的Stream是单向的

- NIO（jdk1.4 之后  linux的多路复用技术 select 模式）：Non IO 同步非阻塞 IO，是传统 IO 的升级，提供了 Channel、Selector、Buffer 等新的抽象，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。Mina2.0和Netty5.0网络通信框架都是通过NIO实现的网络通信。NIO是面向缓冲区的，NIO的channel是双向的。

  > NIO 能解决什么问题？
  >
  > 通过一个固定大小的线程池，来负责管理工作线程，避免频繁创建、销毁线程的开销，这是我们构建并发服务的典型方式。
  >
  > NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。

- AIO（jdk  1.7过后 又叫NIO 2）：Asynchronous IO 异步非堵塞 IO，是 NIO 的升级，异步 IO 的操作基于事件和回调机制，性能是最好的。底层实现是通过epoll的I/O多路复用机制。